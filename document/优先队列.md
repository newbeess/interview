# 优先队列

> - 使用场景不需要一次就排好序，而是每次取最大或最小处理。
>
> - 支持插入元素、删除最大元素操作
> - 和队列（删除最老元素）、栈（删除最新元素）类似

**数组、链表（线性复杂度）、堆（对数复杂度）作为数据结构都可以实现优先队列，**

对于含有N个元素基于堆的优先队列，插入操作最多lgN+1次比较，删除堆顶操作最多2*lgN次比较

1.数组实现（无序/有序数组）

``` java
// 通过无序数组实现优先队列
public class UnorderedArrayTopM<Key extends Comparable<Key>> {

    Key[] pq;      // elements
    int n;         // number of elements

    // 设置堆的初始大小以容纳大小元素
    public UnorderedArrayTopM(int capacity) {
        pq = (Key[]) new Comparable[capacity];
        n = 0;
    }
    public boolean isEmpty()   { return n == 0; }
    public int size()          { return n;      }
    public void insert(Key x)  { pq[n++] = x;   }

    public Key delMax() {
        int max = 0;
        for (int i = 1; i < n; i++)  // for循环找到最大元素
            if (less(max, i)) max = i;
        exch(pq, max, n-1);

        return pq[--n];
    }
}

// 通过有序数组实现优先队列
public class OrderedArrayTopM<Key extends Comparable<Key>> {
    private Key[] pq;          // elements
    private int n;             // number of elements

  	// 设置堆的初始大小以容纳大小元素
    public OrderedArrayTopM(int capacity) {
        pq = (Key[]) (new Comparable[capacity]);
        n = 0;
    }

    public boolean isEmpty() { return n == 0;  }
    public int size()        { return n;       }
    public Key delMax()      { return pq[--n]; }

    public void insert(Key key) {
        int i = n-1;
        // 从后往前遍历 直到有元素不小于插入元素key
        while (i >= 0 && less(key, pq[i])) {
            pq[i+1] = pq[i];  // 向后移
            i--;
        }
        pq[i+1] = key;  // 插入
        n++;   // 元素个数加一
    }
}
```

