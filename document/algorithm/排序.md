# 排序算法

[算法可视化网站](https://visualgo.net/en/sorting)

- ## 基本排序算法

#### 选择排序（selection sort）

> 暴力算法。双层for循环，无论数组是否有序，都要遍历一遍，每次找出最小的数字，交换。 

**长度为N的数组，选择排序要大约N<sup>2</sup>/2次比较和N次交换，最好：0次交换，N<sup>2</sup>/2次比较**

<img src="../media/picture/selectSort.gif">

``` java
for (int i = 0; i < sourceArray.length; i++) {
  int min = i;
  for (int j = i + 1; j < sourceArray.length; j++) {
    if (sourceArray[j] < sourceArray[min]) {
      min = j;
    }
  }
  if (i != min) {
    swap(sourceArray, i, min);
  }
}
```

#### 插入排序（insert）

> 类似整理扑克牌的思路，每次插入有序的牌中。
>
> 部分有序的情况下比选择排序适合，有序的情况下比较N次就结束。

**长度为N的数组，最好情况N-1次比较，0次交换，最坏N<sup>2</sup>/2次比较、N<sup>2</sup>/2次交换**

<img src="../media/picture/insertSort.gif">

``` java
for (int i = 1; i < sourceArray.length; i++) {
  for (int j = i; j > 0; j--) {
    if (sourceArray[j] < sourceArray[j - 1]) {
      swap(sourceArray, j, j - 1);
    } else {
      break;
    }
  }
}
```

#### 希尔排序（Shell）

> 改进版的插入排序
>
> - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
> - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

**长度为N的数组，时间复杂度：N<sup>1.3~2</sup>**

<img src="/Users/chaofu/Desktop/shellSort.png" alt="shellSort" style="zoom:75%;" />

``` java
for (int gap = sourceArray.length / 2; gap >= 1; gap = gap / 2) {
  for (int i = gap; i < sourceArray.length; i++) {
    for (int j = i; j >= gap; j = j - gap) {
      if (sourceArray[j] < sourceArray[j - gap]) {
        swap(sourceArray, j, j - gap);
      } else {
        break;
      }
    }
  }
}
```



- ## 归并排序（分治）

> 将两个有序的数组归并为一个更大的有序数组，

**长度为N的数组，时间复杂度为线性对数O(N*lgN)，空间复杂度O(N)**

#### 基础合并两数组算法API

``` java
private void merge(long[] arr, int low, int mid, int hi) {
    int left = low, right = mid + 1, k = 0;
    long[] temp = new long[hi - low + 1];
    
    while (left <= mid && right <= hi) {
      if (arr[left] <= arr[right]) {
        temp[k++] = arr[left++];
      } else {
        temp[k++] = arr[right++];
      }
    }
    while (left <= mid) {
      temp[k++] = arr[left++];
    }
    
    while (right <= hi) {
      temp[k++] = arr[right++];
    }
    
    for (int i = 0; i < temp.length; i++) {
      arr[low + i] = temp[i];
    }
  }
```

#### 自顶向下的排序（递归方式）

<img src="../media/picture/mergeSort1.png">

``` java
  public void sort(long[] sourceArray) {
    this.mergeSort(sourceArray, 0, sourceArray.length - 1);
  }

  /**
   * 递归的拆分问题到单个元素 左闭右闭
   */
  private void mergeSort(long[] arr, int l, int r) {
    //递归终止条件
    if (l >= r) {
      return;
    }
    int m = l + (r - l) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    merge(arr, l, m, r);

  }
```

#### 自底向上的排序（非递归，循环方式）

<img src="../media/picture/mergeSort2.png">

``` java
  public void sort(long[] sourceArray) {
    int N = sourceArray.length;
    for (int gap = 1; gap < N; gap = 2 * gap) {
      for (int lo = 0; lo < N - gap; lo = lo + 2 * gap) {
        this.merge(sourceArray, lo, lo + gap - 1, Math.min(N - 1, lo + 2 * gap));
      }
    }
  }
```

- ## 快速排序（分治）

> 选取pivot，对整个数组小于pivot移动到左边，大于pivot移动到右边，然后，分别对pivot左右两侧递归调用刚刚到过程。

**长度为N的数组，平均时间复杂度为**O(N*lgN)，最坏情况下O(N<sup>2</sup>)。

<img src="../media/picture/quickSort.png">

``` java
 public void sort(long[] sourceArray) {
    this.qucikSort(sourceArray, 0, sourceArray.length - 1);
  }

  private void qucikSort(long[] a, int lo, int hi) {
    if (lo >= hi) {
      return;
    }
    int pivot = this.partition(a, lo, hi);
    qucikSort(a, lo, pivot - 1);
    qucikSort(a, pivot + 1, hi);
  }
```

#### partition方法

``` java

  /**
   * 返回pivot，并且数组左边小与pivot位置的值，右边大与pivot位置的值
   *
   * @param a
   * @param lo
   * @param hi
   * @return
   */
  private int partition(long[] a, int lo, int hi) {
    long pivotValue = a[lo];
    int i = lo, j = hi;

    while (i < j) {
      while (i < j) {
        if (a[i] < pivotValue) {
          i++;
        } else {
          break;
        }
      }
      while (i < j) {
        if (a[j] > pivotValue) {
          j--;
        } else {
          break;
        }
      }
      if (i >= j) {
        break;
      }
      swap(a, i, j);
    }
    return i;
  }
```

- ## 冒泡排序

> 通过两两比较，每次在最后的位置冒泡出最大元素

**长度为N的数组，平均时间复杂度O(N<sup>2</sup>)**

<img src="../media/picture/bubbleSort.gif">

``` java
  public void sort(long[] sourceArray) {
    for (int i = sourceArray.length - 1; i > 0; i--) {
      for (int j = 0; j < i; j++) {
        if (sourceArray[j] > sourceArray[j + 1]) {
          swap(sourceArray, j, j + 1);
        }
      }
    }
  }
```

- ## 堆排序

> 堆的性质：
>
> > 1.完全二叉树
> >
> > 2.父节点大于或小于子节点
>
> 节点i的父节点和子节点计算公式
>
> > parent = (i-1)/2
> >
> > child1= 2*i+1
> >
> > child2=2*i+2

**时间复杂度O(N*lgN)，空间复杂度O(1)**

- 普通堆排序，每次调用delMax函数，直到堆空为止

- 原地堆排序

> 1. 创建一个堆
> 2. 把堆首（最大值）和堆尾互换
> 3. 把堆的尺寸缩小1，heapify函数调整堆首,目的是把新的数组顶端数据调整到相应位置
> 4. 重复步骤2，直到堆的尺寸为1

``` java
/**
*	调整i节点的位置
* 1.选出i节点和左右孩子三者中的较大值
* 2.如果i节点最大，结束
* 3.否则交换i和左或右孩子
* 4.调整左或有子树
*/
private void heapify(long[] tree, int n, int i) {
    while (i < n) {
      int c1 = 2 * i + 1;
      int c2 = 2 * i + 2;
      int max = i;
      if (c1 < n && tree[c1] > tree[max]) {
        max = c1;
      }
      if (c2 < n && tree[c2] > tree[max]) {
        max = c2;
      }
      if (max == i) {
        break;
      }
      swap(tree, i, max);
      i = max;
    }
  }
```

``` java
/**
*构建堆（使得根节点>左右孩子节点）
* 从最后一个非叶子节点开始直到根节点
* 调整每个节点的位置，使得每个位置都满足堆堆性质
*/
private void buildHeap(long[] tree, int n) {
    int lastNode = n - 1;
    int parentNode = (lastNode - 1) / 2;
    for (int i = parentNode; i >= 0; i--) {
      heapify(tree, n, i);
    }
  }
```



``` java
/**
* 原地堆排序
* 1.构建堆
* 2.交换堆首和当前堆尾部
* 3.堆堆大小减1，直到堆的大小为0
* 3.调整堆首
*/
public void sort(long[] sourceArray) {
    int N = sourceArray.length;
    buildHeap(sourceArray, N);
    for (int i = N - 1; i >= 0; i--) {
      swap(sourceArray, i, 0);
      heapify(sourceArray, i, 0);
    }
  }
```

